# exploit.rb
# Part of the core module, holds all of the data for the
# exploit to be used 
# 
# created 2010-03-29 by seth
#


require 'webrick'

module WXf
module WXfdb


class Exploit
  
  include WXf::WXfassists::General::MechReq
 
  attr_accessor :id, :name, :desc, :type, :lang, :method, :url, :headers, :params, :required, :optional, :options, :svr
  
  def initialize(exploit)
    (self.id, self.name, self.desc, self.type, self.lang, self.method, self.url, self.headers, pars, val) = exploit
    values = eval("#{val}")
    self.params = eval("#{pars}")
    self.required = values[:required]
    self.optional = values[:optional]
    self.options = {}
    self.options.merge!(self.required)
    self.options.merge!(self.optional)
  end
  

  
  def run_rfi_exploit(p,lh)
    
    payload = p.get_rfi_payload(self.method)
    p_params = p.get_rfi_payload_params
    
    case self.method
      when "GET", "POST"
        rparams = self.params
        rparams.merge!(p_params)
        
        rparams.each_pair { |k,v|
          if v.respond_to?('match') and v.match(/<#>(\w+)<%>?/)
            x = v.match(/<#>(\w+)<%>/)
            if self.options.has_key?(x[1])
              rparams[k] = self.options[x[1]]
            elsif (x[1] =~ /PAYLOAD/)
              rparams[k] = payload
            end
          end
          
        }
        end
        
        rurl = self.options["RURL"]
        
        lh.out "Exploit URL for delivery: #{rurl}"
        begin

          handler_request = mech_req(
            {
              'method' => self.method,  
              'RURL'   => rurl,
              'RPARAMS' => rparams
            }
          )
            
          hand_resp =  handler_request.body.match(/<#>(.*)<%>?/)    
          return p.get_rfi_payload_result(hand_resp[1])
    
        rescue => $!
          
          print("We've received the following exception: #{$!}" + "\n")
          
    end
    
  end
  
  def run_xss_exploit(p,lh,control)
    
    payload = p.get_xss_payload(self.method)
    p_params = p.get_xss_payload_params
    
    if p.requires_webserver == "1"
      
      lurl = payload.split("/") 
      lhost = lurl[2]
      lport = 80
      if ( lhost =~ /:/ )
        x = lhost.match(/^(.*):(\d+)$/)
        lhost = x[1]
        lport = x[2]
      end
      lpath = "/" + [ lurl[3..lurl.length] ].join("/")
      lsecure = "FALSE"
      if ( lurl[0] =~ /s/ )
        lsecure = "TRUE"
      end
      lfile = PayloadsDir + p.options["LFILE"]
      puts("LHOST: #{lhost}\nLPORT: #{lport}\nLPATH: #{lpath}")
      puts "LFILE: #{lfile}"
        
      opts = {
          "LHOST" => lhost,
          "LPORT" => lport,
          "LPATH" => lpath,
          "LSECURE" => lsecure,
          "LCONTENTTYPE" => nil,
          "LHTML" => nil,
          "LFILE" => nil,
          "LCUSTOMHEADER" => nil
       }
        
      if (lfile != nil)
        opts["LFILE"] = lfile
        begin
          svr = WXf::WXfcore::WebServer.new(opts,control)
          control.enstack_webstack(svr)
          svr.add_file(opts)
          svr.start
          rescue
          print "[wXf] Error when starting the webserver: #{$!}\n"
        end
      else 
       
        svr = WXf::WXfcore::WebServer.new(opts,control)
        control.enstack_webstack(svr)
        ctype = 'text/html'
        if ( p.lang =~ /JS/ )
          ctype = 'text/javascript'
        end
        servlet_opts = {
          "LHTML" => p.options['LHTML'],
          "TXT" => p.options['TXT'],
          "LCONTENTTYPE" => ctype,
          "LFILE" => nil
        }
        
        servlet = WXf::WXfcore::Configurable
        svr.add_servlet(lpath, servlet, servlet_opts)
        svr.start
      end
    
    end
    
    case self.method
      when "GET"
        url = self.options['RURL']
        all_params = {}
        all_params.merge!(self.params)
        all_params.merge!(p_params)
        if (all_params.length > 0)
          count = 0
          all_params.each { |k,v|
            if ( count == 0 )
              url = url + "?"
            else
              url = url + "&"
            end
            url = url + "#{k}=#{v}"
          }
        end
                
        while url.match(/<#>(\w+)<%>?/)
          x = url.match(/<#>(\w+)<%>?/) 
          if self.options.has_key?(x[1])
            k = x[1]
            url = "#{url}".gsub(x[0],"#{self.options[k]}")
          elsif (x[1] =~ /PAYLOAD/)
            url = "#{url}".gsub(x[0],payload)
          else
            url.sub(/<#>\w+<%>/,"FAIL")
          end
        end
        lh.out "URL: #{url}"
      
      when "PUT"
    end
  end
  
  def run_sql_exploit(p,hh)
  end
  
  def dis_required_opts
    # Display the commands
      tbl = WXf::WXfui::Console::Prints::PrintTable.new(
      'Justify'  => 4,             
      'Columns' => 
      [
      'Name',
      'Current Setting',
      'Required',
      'Description',       
       ])
         
      self.required.each { |k,v|
      tbl.add_ritems([k,v.to_s, "yes"])
      }
      self.optional.each { |k,v|
      tbl << [k,v.to_s, "no"] 
      }
      tbl.prnt
end

 

    def usage
    
    $stderr.puts("\n"+"Exploit (#{self.name}) options:")
    dis_required_opts     
   
  end
    

end
  
       
end
end