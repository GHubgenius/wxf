#
# Class used to call the db, create an instance of an exploit and run
#


module WXf
module WXfconductors
  
  class Db_Exploit_Conductor
    
    attr_accessor :exp, :pay, :svr
    
    def initialize(name)          
      self.exp  = WXf::WXfdb::Exploit.new(exploit_call("#{name}")[0])      
      self.pay = nil          
    end
    
    
    #
    # Defines the type of module
    #
    def type
     DB_EXP
    end
    
    
    #
    # Need to build this out so that we can grab the attr from 
    # ...the module called and update the prompt with it.
    #
    def name   
    end  
    
    #
    # Gives and instance from which to interace with the core class
    #
    def wxf    
      WXf::WXfdb::Core.new(WXFDIR,1)
    end  
    
    
    #
    # Exploit call to the exploits portion of the db
    #
    def exploit_call(args)       
       wxf.db.get_exploit_by_name(args)        
     end
    
    #
    # We need to initiate a webserver instance
    #
    def webserver_start(opts, control)
     begin
        svr = WXf::WXfwebserver::WebServer.new(opts,control)
        control.add_web_activity(svr)
        svr.add_file(opts)
        svr.start
        rescue
         print "[wXf] Error when starting the webserver: #{$!}\n"
      end      
    end
    
     
    #
    # Instead of a user firing up a webserver instance, then using the exploit,
    # ...we'd prefer to just fire it up for them. 
    #
    def webserver_init(control)
      opts = default_opts
      
      # We need to ensure that we have a matched payload to file to render
      # ...we will have to add logic for content that is not file based
      lfiles = control.framework.modules.lfile_load_list
      lfiles.each do |name, path|
        true_lfile_name = name.split('/').last
          if self.pay.respond_to?('content') and self.pay.content.match(/#{true_lfile_name}/)
            opts['LFILE'] = lfiles[name]
          end
      end
      
      if (control)
        #Extract key-value pairs from default_opts
        lport = opts['LPORT']
        lhost = opts['LHOST']
        prefix = opts['PREFIX']  
      
        # Remove a colon if it exists  
        lport.to_s.gsub!(':', '')
        
        # This is where we give the user options and let them decide how to fire up 
        # ...the webserver instance
        puts("Local Port to use: (#{lport})?\n" + "Hit Enter or Type New Port")
        STDOUT.flush
        input_lport = gets.chomp
        
        # The user has set their options, lets validate
        if default?(input_lport) == false
          opts['LPORT'] = input_lport
        end
        
        webserver_start(opts, control)
        sleep 5.0
      end
    end   
    
    #
    # Method which performs a check to see if the user simply chose default options
    # or entered something new.
    #    
    def default?(input)
      if input == '' 
        return true
      else
        return false
      end
    end
    
    
    #
    # This checks to see if we have some default LURL options that we can employ when starting a webserver
    #
    def default_opts
      opts = {}
          # First, let's add some intelligence to this method in order to dynamically
          # ...assign default values to IP and PORT.
          if self.pay.respond_to?('options')
             # 
             lurl = self.pay.options['LURL']
           if (lurl)
             # Regex operations to extract address, port and prefix           
             prefix = lurl.match(/(http:\/\/|https:\/\/)/)
             plurl = lurl.gsub("#{prefix}", '')           
             lhost = plurl.match(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/)
             lport = plurl.match(/:+\d{1,5}/)
             
             # Assign the key, value pairs in opts 
             if (prefix)
               opts['PREFIX'] = prefix.to_s
             else
               opts['PREFIX'] = 'http://'
             end
             
             if (lhost)
               opts['LHOST'] = lhost.to_s
             else
               opts['LHOST'] = '127.0.0.1'
             end
             
             if (lport)
               opts['LPORT'] = lport.to_s
             else
               opts['LPORT'] = '8888'
             end
             
           end
          end  
      # Return this hash when the default_opts method is called    
      return opts
    end 
     
    
    #
    # Run that bad-boy
    #     
    def run_exploit(control)
      
      # Keeps us from trying to merge options on an object that doesn't exist      
      unless self.pay == nil 
        
      # Merging of options is a necessary evil        
      self.pay.options.merge!(self.pay.required).merge!(self.pay.optional)      
      self.exp.options.merge!(self.exp.required).merge!(self.exp.optional)
        
      #Ask the user if they'd like us to start a webserver instance (in case of RFI)
      if self.exp.respond_to?('type') and self.exp.type.match(/(RFI)/)
        puts("Would you like us to start a webserver instance for you? (y/n)\n")
        STDOUT.flush
        answer = gets.chomp.downcase
       if answer == 'y'
        webserver_init(control)
       end
      end  
       
       #This actually runs the db based exploit
       wxf.run_exploit(self.exp, self.pay, control)           
    
      else        
           print("Don't forget to choose a payload!" + "\n")
      end
    end
    
  end
  
end
end